---
title: "Write Path"
description: "Understand how Laravel Chorus handles client writes, validation, offline support, and conflict resolution."
---

# Write Path

The **write path** in Laravel Chorus handles how client-side changes are processed, validated, and synchronized back to the server. This system enables optimistic updates, offline support, and robust conflict resolution.

## Write Path Overview

```mermaid
graph TD
    A[Client Action] --> B[Optimistic Update]
    B --> C[Local IndexedDB]
    A --> D[Server Request]
    D --> E{Online?}
    E -->|Yes| F[Chorus Action]
    E -->|No| G[Offline Queue]
    F --> H{Validation}
    H -->|Pass| I[Database Updates]
    H -->|Fail| J[Rejected Harmonic]
    I --> K[Create Harmonics]
    K --> L[Broadcast to Clients]
    L --> M[Client Confirmation]
    J --> N[Client Rollback]
    G --> O[Sync When Online]
```

## Chorus Actions

Chorus Actions are server-side classes that handle client write operations with validation, authorization, and business logic. They can execute multiple database operations in a single transaction.

### Basic Chorus Action

```php
<?php

namespace App\Actions\ChorusActions;

use App\Models\Message;
use App\Models\User;
use App\Models\Platform;
use Illuminate\Http\Request;
use Pixelsprout\LaravelChorus\Support\ChorusAction;
use Pixelsprout\LaravelChorus\Support\ActionCollector;

final class CreateMessageWithActivityAction extends ChorusAction
{
    public function rules(): array
    {
        return [
            'messages.create' => [
                'id' => 'nullable|uuid',
                'body' => 'required|string|max:1000',
                'platform_id' => 'required|uuid|exists:platforms,id',
                'user_id' => 'required|uuid|exists:users,id',
                'tenant_id' => 'required|uuid',
            ],
            'users.update' => [
                'id' => 'required|uuid|exists:users,id',
                'last_activity_at' => 'required|date',
            ],
            'platforms.update' => [
                'id' => 'required|uuid|exists:platforms,id',
                'last_message_at' => 'nullable|date',
                'message_count' => 'nullable|numeric',
            ],
        ];
    }

    protected function handle(Request $request, ActionCollector $actions): void
    {
        // Authorization check
        $this->authorize('create', Message::class);

        $data = $request->all();

        // Execute multiple operations atomically (UUID auto-generated on client)
        $actions->messages->create([
            'id' => $data['id'], // UUID provided by client
            'body' => $data['body'],
            'user_id' => auth()->id(),
            'platform_id' => $data['platform_id'],
            'tenant_id' => auth()->user()->tenant_id,
        ]);

        // Update user activity
        $actions->users->update([
            'id' => auth()->id(),
            'last_activity_at' => now(),
        ]);

        // Update platform metrics
        $actions->platforms->update([
            'id' => $data['platform_id'],
            'last_message_at' => now(),
            'message_count' => \DB::raw('message_count + 1'),
        ]);
    }
    
    protected function authorize(string $ability, $model): void
    {
        if (!auth()->user()->can($ability, $model)) {
            throw new UnauthorizedException("Unauthorized to {$ability} messages");
        }
    }
}
```

### Simple Update Action

```php
<?php

namespace App\Actions\ChorusActions;

use App\Models\Message;
use Illuminate\Http\Request;
use Pixelsprout\LaravelChorus\Support\ChorusAction;
use Pixelsprout\LaravelChorus\Support\ActionCollector;

final class UpdateMessageAction extends ChorusAction
{
    public function rules(): array
    {
        return [
            'messages.update' => [
                'id' => 'required|uuid|exists:messages,id',
                'body' => 'required|string|max:1000',
                'updated_at' => 'nullable|date',
            ],
            'users.update' => [
                'id' => 'required|uuid|exists:users,id',
                'last_activity_at' => 'required|date',
            ],
        ];
    }

    protected function handle(Request $request, ActionCollector $actions): void
    {
        $data = $request->all();
        $messageId = $data['id'];
        $message = Message::findOrFail($messageId);
        
        // Authorization check
        $this->authorize('update', $message);
        
        // Optimistic locking check
        if (isset($data['updated_at'])) {
            $expectedUpdatedAt = Carbon::parse($data['updated_at']);
            if ($message->updated_at->gt($expectedUpdatedAt)) {
                throw new ConflictException('Message was updated by another user');
            }
        }
        
        // Update the message
        $actions->messages->update([
            'id' => $messageId,
            'body' => $data['body'],
            'is_edited' => true,
            'edited_at' => now(),
        ]);
        
        // Update user activity
        $actions->users->update([
            'id' => auth()->id(),
            'last_activity_at' => now(),
        ]);
    }
    
    protected function authorize(string $ability, $model): void
    {
        if (!auth()->user()->can($ability, $model)) {
            throw new UnauthorizedException("Unauthorized to {$ability} this message");
        }
    }
}
```

### Delete Action

```php
<?php

namespace App\Actions\ChorusActions;

use App\Models\Message;
use Illuminate\Http\Request;
use Pixelsprout\LaravelChorus\Support\ChorusAction;
use Pixelsprout\LaravelChorus\Support\ActionCollector;

final class DeleteMessageAction extends ChorusAction
{
    public function rules(): array
    {
        return [
            'id' => 'required|string|uuid',
        ];
    }

    protected function handle(Request $request, ActionCollector $actions): void
    {
        $user = auth()->user();

        if (!$user) {
            throw new \Exception('User must be authenticated');
        }

        $data = $request->all();
        
        // Delete the message using the action collector
        $actions->messages->delete([
            'id' => $data['id'],
        ]);

        // Update user's last activity timestamp
        $actions->users->update([
            'id' => $user->id,
            'last_activity_at' => now(),
        ]);
    }
    
    protected function authorize(string $ability, $model): void
    {
        if (!auth()->user()->can($ability, $model)) {
            throw new UnauthorizedException("Unauthorized to {$ability} this message");
        }
    }
}
```

## Chorus Action Configuration

### Action Registration

Register Chorus Actions in your routes:

```php
// routes/chorus.php
use App\Actions\ChorusActions\CreateMessageWithActivityAction;
use App\Actions\ChorusActions\UpdateMessageAction;
use App\Actions\ChorusActions\DeleteMessageAction;

Route::chorus('create-message-with-activity', CreateMessageWithActivityAction::class);
Route::chorus('update-message', UpdateMessageAction::class);
Route::chorus('delete-message', DeleteMessageAction::class);
```

### Automatic Features

All Chorus Actions automatically support:
- **Offline writes** - Operations are queued when offline and synced when reconnected
- **Batch operations** - Multiple items can be processed in a single request
- **Optimistic updates** - UI updates immediately while server processes in background

## Single Operation Shorthand

For actions with only one operation rule, you can use a simplified data format:

```php
// Single operation action
final class SimpleCreateMessageAction extends ChorusAction
{
    public function rules(): array
    {
        return [
            'messages.create' => [
                'body' => 'required|string|max:1000',
                'platform_id' => 'required|uuid|exists:platforms,id',
            ],
        ];
    }

    protected function handle(Request $request, ActionCollector $actions): void
    {
        $data = $request->all();
        
        // UUID auto-generated on client, just use the provided data
        $actions->messages->create([
            'id' => $data['id'], // UUID provided by client
            'body' => $data['body'],
            'platform_id' => $data['platform_id'],
            'user_id' => auth()->id(),
        ]);
    }
}
```

**Client-side usage:**

```typescript
// Full format (always works) - UUID auto-generated
await createMessageAction((writes) => {
    writes.messages.create({
        body: "Hello world",
        platform_id: "abc-123"
    });
});

// Shorthand format (single operation only) - UUID auto-generated
await createMessageAction({
    body: "Hello world", 
    platform_id: "abc-123"
});
```

## Client-Side Chorus Actions

### Using Generated Action Functions

Chorus generates TypeScript functions for each registered action:

```tsx
import { createMessageWithActivityAction, updateMessageAction, deleteMessageAction } from '@/_generated/chorus-actions';
import { uuidv7 } from 'uuidv7';

export default function MessageForm() {
    const handleCreate = async (body: string, platformId: string) => {
        const messageId = uuidv7();
        
        const result = await createMessageWithActivityAction((writes) => {
            // Create the message
            writes.messages.create({
                id: messageId,
                body,
                platform_id: platformId,
                user_id: user.id,
                tenant_id: user.tenant_id,
            });
            
            // Update user activity (handled automatically)
            writes.users.update({
                id: user.id,
                last_activity_at: new Date().toISOString(),
            });
            
            // Update platform metrics (handled automatically)
            writes.platforms.update({
                id: platformId,
                last_message_at: new Date().toISOString(),
            });
        });
        
        if (result.success) {
            console.log('Message created successfully:', result);
        } else {
            console.error('Message creation failed:', result.error);
        }
    };
    
    const handleUpdate = async (messageId: string, newBody: string) => {
        await updateMessageAction((writes) => {
            writes.messages.update({
                id: messageId,
                body: newBody,
            });
        });
    };
    
    const handleDelete = async (messageId: string) => {
        if (!confirm('Delete this message?')) return;
        
        await deleteMessageAction((writes) => {
            writes.messages.delete(messageId);
        });
    };
    
    return (
        <form onSubmit={(e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            handleCreate(formData.get('body'), formData.get('platform_id'));
        }}>
            <textarea name="body" required />
            <select name="platform_id" required>
                <option value="">Select Platform</option>
                {/* Platform options */}
            </select>
            <button type="submit">Send Message</button>
        </form>
    );
}
```

## Shadow and Delta Tables

For complex offline synchronization, Chorus can use shadow tables to track local changes.

### Shadow Table Concept

Shadow tables store a copy of the server data, allowing detection of both local and server changes:

```mermaid
erDiagram
    messages {
        string id "UUID primary key"
        string body "Message content"
        number user_id "User identifier"
        number created_at "Unix timestamp"
        number updated_at "Unix timestamp"
    }

    messages_shadow {
        string body "Server state snapshot"
        number user_id "User identifier"
        number created_at "Unix timestamp"
        number updated_at "Unix timestamp"
        number synced_at "Last sync timestamp"
    }

    messages_delta {
        number id "primary key"
        string operation "create|update|delete"
        object data "Change payload as object"
        string sync_status "pending|synced|rejected"
    }

    messages ||--o{ messages_delta : "generates changes"
    messages ||--|| messages_shadow : "optimistic mirror"
```

## Next Steps

<CardGroup cols={2}>
<Card title="Advanced Features" href="/advanced/channel-prefixes" icon="gear">
Explore advanced configuration and multi-tenancy
</Card>

<Card title="React Integration" href="/integrations/react" icon="react">
Use Chorus Actions in your React components
</Card>
</CardGroup>

---

The write path is where Laravel Chorus shines, providing robust offline support, conflict resolution, and validation while maintaining instant user experiences through optimistic updates. With Chorus Actions, you can execute multiple operations atomically in a single transaction.